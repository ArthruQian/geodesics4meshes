- en entrée obligatoire : un champ de tenseur T + une matrice de labels S (0 si aucun label, >=1 si un label, <0 si extérieur au domaine: seeds ponctuels ou non)

1) Distance + Voronoi à partir de l'entrée obligatoire
  [U,V,dUx,dUy] = anisoVoronoi2Diterative(T,S);

2) Distance + Voronoi à partir de l'entrée obligatoire + un U et un V déjà calculés
  [dUx,dUy] = anisoVoronoi2Diterative(T,S,U,V);
  --> dans ce cas les nouveaux seeds sont renseignés dans S, U (par exemple U[s]=0), V (même valeur que dans S)
  --> attention les matrices U et V sont maintenant directement modifiées (il faut que je fasse de même pour dUx et dUy, ça accélère les calculs)

3) pareil qu'au 1) et 2) mais contraint à un domaine: il suffit que les points en dehors du domaine aient S négatif

pour voir le fonctionnement, regardes les exemples du fichier .m du dossier "main" en les lançant dans l'ordre et sans fermer les figures (sinon c'est la catastrophe)

Précision sur l'algo d'ajout (local) de nouveaux seeds: j'ai testé deux manières
a) exemple 2: initialisation avec les anciens seeds et les nouveaux
b) exemple 3: initialisation avec les nouveaux seeds seulement
dans les 2 cas les valeurs déjà calculées sont mises à jour à partir de ces initialisations. La mise à jour s'arrête naturellement sans test supplémentaire par rapport à la version classique.
Si on suppose que les valeurs de U ont été correctement calculées à l'étape précédente, il suffit de faire b) car il n'y a aucune raison d'aller modifier une valeur en partant d'un ancien seed. En pratique, j'ai observé quelques différences entre a), b) et la version classique (à partir de tous les seeds), avec une différence plus importante avec b)
% P.S. : l'exemple 4 pourrait être intéressant avec une bonne métrique
